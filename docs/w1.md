# Woche 1 (7. November)

## Minimalbeispiel: Verändern von Speicheradresse

```C
// lädt '0' in die Adresse, auf die RDX zeigt
int64_t num = 0;
ptrace(PTRACE_POKEDATA, pid, regs.rdx, num);
```

## Minimalbeispiel: Stepper-Syscalls

**Vor** und **nach** jedem Syscall wird der Tracee ge-trapt und der Tracer erlangt Kontrolle.
Wichtig ist der Toggle, damit zwischen `@before` und `@after` unterschieden werden kann.  
Wollen wir den `RAX` auslesen, dann sollten wir `orig_rax` verwenden, `rax` ist lediglich nützlich, wenn wir im `@after` Teil den Rückgabewert (im RAX) des Syscalls auslesen wollen.

Struktur:

```C
// warten auf erneuten interrupt und ggf. (sys_exit) handling von Beendigung des tracees.
waitpid(pid, &status, 0);   
if(WIFEXITED(status)) { handle(); }

// before-after toggle
if(toggle)
{
    toggle = 0;

    @after
}
else
{
    toggle = 1;

    @before
} 

// ge-trap-ten Callee wieder fortsetzen, dabei neuen Breakpoint am nächsten Syscall Interrupt setzen.
ptrace(PTRACE_SYSCALL, pid, 0,0);
```

## Minimalbeispiel: Stepper-Singlesteps

Ähnlich zu `Stepper-Syscalls`, nur dass ein Toggle nicht notwendig ist, da pro Instruktion nur ein Interrupt stattfindet.

```C
// warten auf erneuten interrupt und ggf. (sys_exit) handling von Beendigung des tracees.
waitpid(pid, &status, 0);   
if(WIFEXITED(status)) { handle(); }

@do

//ge-trap-ten Callee wieder fortsetzen, dabei neuen Breakpoint nach der nächsten Instruktion
ptrace(PTRACE_SINGLESTEP, pid, 0,0); 
```

## Socketprogrammierung

*// todo*

## Struct Reihenfolge

Für die Reihenfolge des Stackframe kommt es auf den stack protector an:

- `-fstack-protector`: stack wächst von unten nach oben
- `-fno-stack-protector`: stack wächst von oben nach unten

Structs wachsen von **unten** nach **oben**.
Dabei ist die Adresse des Struts die Adresse des ersten Elements.

## Artikel Implementieren

Im Artikel werden folgende wichtige Befehle von ptrace vorgestellt:
- `PTRACE_GETREGS` speichert alle Adressen vom Zielprozess in einem struct.
- `PTRACE_PEEKUSER` liest ebenfalls Speicher aus, aber nur eine Adresse.
- `PTRACE_ATTACH` und PTRACE_DETACH um sich an andere Prozesse anzuklinken.
- `PTRACE_SYSCALL` lässt tracee wieder weiterlaufen.  
Weitere Formen und wichtige Befehle auf: [link](http://man7.org/linux/man-pages/man2/ptrace.2.html)

Checkliste für Implementiereung von 32 Bit zu 64 Bit:
- Bibliotheken anpassen (z.B `<linux.user.h>` zu `<sys/reg.h>` ändern)
- alle Speicheradressen namentlich ändern und Adress-Arithmetik beachten (z.B. 4\*EAX zu 8\*RAX ändern)

## Signale Aufräumen

*// todo*